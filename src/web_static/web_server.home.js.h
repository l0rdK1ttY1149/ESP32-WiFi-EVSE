static const char CONTENT_HOME_JS[] PROGMEM = 
  "// OpenEVSE comms library\n"
  "//\n"
  "// Based (loosely) on https://github.com/tiramiseb/python-openevse/\n"
  "\n"
  "/* global $ */\n"
  "/* jshint node: true, bitwise: false*/\n"
  "\n"
  "\"use strict\";\n"
  "\n"
  "function OpenEVSEError(type, message = \"\") {\n"
  "  this.type = type;\n"
  "  this.message = message;\n"
  "}\n"
  "\n"
  "function OpenEVSERequest()\n"
  "{\n"
  "  var self = this;\n"
  "  self._done = function() {};\n"
  "  self._error = function() {};\n"
  "  self._always = function() {};\n"
  "  self.done = function(fn) {\n"
  "    self._done = fn;\n"
  "    return self;\n"
  "  };\n"
  "  self.error = function(fn) {\n"
  "    self._error = fn;\n"
  "    return self;\n"
  "  };\n"
  "  self.always = function(fn) {\n"
  "    self._always = fn;\n"
  "    return self;\n"
  "  };\n"
  "}\n"
  "\n"
  "/* exported OpenEVSE */\n"
  "function OpenEVSE(endpoint)\n"
  "{\n"
  "  var self = this;\n"
  "  self._version = \"0.1\";\n"
  "  self._endpoint = endpoint;\n"
  "  self.states = {\n"
  "    0: \"unknown\",\n"
  "    1: \"not connected\",\n"
  "    2: \"connected\",\n"
  "    3: \"charging\",\n"
  "    4: \"vent required\",\n"
  "    5: \"diode check failed\",\n"
  "    6: \"gfci fault\",\n"
  "    7: \"no ground\",\n"
  "    8: \"stuck relay\",\n"
  "    9: \"gfci self-test failure\",\n"
  "    10: \"over temperature\",\n"
  "    11: \"over current\",\n"
  "    254: \"sleeping\",\n"
  "    255: \"disabled\"\n"
  "  };\n"
  "  self._lcd_colors = [\"off\", \"red\", \"green\", \"yellow\", \"blue\", \"violet\", \"teal\", \"white\"];\n"
  "  self._status_functions = {\"disable\":\"FD\", \"enable\":\"FE\", \"sleep\":\"FS\"};\n"
  "  self._lcd_types=[\"monochrome\", \"rgb\"];\n"
  "  self._service_levels=[\"A\", \"1\", \"2\"];\n"
  "\n"
  "  // Timeouts in seconds\n"
  "  self.STANDARD_SERIAL_TIMEOUT = 0.5;\n"
  "  self.RESET_SERIAL_TIMEOUT = 10;\n"
  "  self.STATUS_SERIAL_TIMEOUT = 0;\n"
  "  self.SYNC_SERIAL_TIMEOUT = 0.5;\n"
  "  self.NEWLINE_MAX_AGE = 5;\n"
  "\n"
  "  self.CORRECT_RESPONSE_PREFIXES = (\"$OK\", \"$NK\");\n"
  "\n"
  "  self.regex = /\\$([^^]*)(\\^..)?/;\n"
  "\n"
  "  self._request = function(args, callback = function() {})\n"
  "  {\n"
  "    var command = \"$\" + (Array.isArray(args) ? args.join(\"+\") : args);\n"
  "\n"
  "    var request = new OpenEVSERequest();\n"
  "    $.get(self._endpoint + \"?json=1&rapi=\"+encodeURI(command), function (data) {\n"
  "      var match = data.ret.match(self.regex);\n"
  "      if(null !== match)\n"
  "      {\n"
  "        var response = match[1].split(\" \");\n"
  "        if(\"OK\" === response[0]) {\n"
  "          callback(response.slice(1));\n"
  "          request._done(response.slice(1));\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"OperationFailed\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"UnexpectedResponse\"));\n"
  "      }\n"
  "    }, \"json\").always(function () {\n"
  "      request._always();\n"
  "    }).fail(function () {\n"
  "      request._error(new OpenEVSEError(\"RequestFailed\"));\n"
  "    });\n"
  "\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Get EVSE controller flags\n"
  "   *\n"
  "   * Specific values:\n"
  "   * - service_level: 1 or 2\n"
  "   * - lcd_type: 'monochrome' or 'rgb'\n"
  "   *\n"
  "   * True for enabled, False for disabled:\n"
  "   * - auto_service_level\n"
  "   * - diode_check\n"
  "   * - gfi_self_test\n"
  "   * - ground_check\n"
  "   * - stuck_relay_check\n"
  "   * - vent_required\n"
  "   * - temp_check\n"
  "   * - auto_start\n"
  "   * - serial_debug\n"
  "   */\n"
  "  self._flags = function (callback)\n"
  "  {\n"
  "    var request = self._request(\"GE\", function(data) {\n"
  "      var flags = parseInt(data[1], 16);\n"
  "      if(!isNaN(flags)) {\n"
  "        var ret = {\n"
  "          \"service_level\": (flags & 0x0001) + 1,\n"
  "          \"diode_check\": 0 === (flags & 0x0002),\n"
  "          \"vent_required\": 0 === (flags & 0x0004),\n"
  "          \"ground_check\": 0 === (flags & 0x0008),\n"
  "          \"stuck_relay_check\": 0 === (flags & 0x0010),\n"
  "          \"auto_service_level\": 0 === (flags & 0x0020),\n"
  "          \"auto_start\": 0 === (flags & 0x0040),\n"
  "          \"serial_debug\": 0 !== (flags & 0x0080),\n"
  "          \"lcd_type\": 0 !== (flags & 0x0100) ? \"monochrome\" : \"rgb\",\n"
  "          \"gfi_self_test\": 0 === (flags & 0x0200),\n"
  "          \"temp_check\": 0 === (flags & 0x0400)\n"
  "        };\n"
  "\n"
  "        callback(ret);\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Failed to parse \\\"\"+data[0]+\"\\\"\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /*** Function operations ***/\n"
  "\n"
  "  /**\n"
  "   * Reset the OpenEVSE\n"
  "   */\n"
  "  self.reset = function ()\n"
  "  {\n"
  "    return self._request(\"FR\");\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Set or get the RTC time\n"
  "   *\n"
  "   * Argument:\n"
  "   *  - a Date object\n"
  "   *\n"
  "   * If the datetime object is not specified, get the current OpenEVSE clock\n"
  "   *\n"
  "   * Returns a datetime object\n"
  "   */\n"
  "  self.time = function(callback, date = false)\n"
  "  {\n"
  "    if(false !== date) {\n"
  "      return self._request([\n"
  "        \"S1\", date.getFullYear() - 2000,\n"
  "        date.getMonth() + 1, date.getDate(),\n"
  "        date.getHours(), date.getMinutes(),\n"
  "        date.getSeconds()], function() {\n"
  "        self.time(callback);\n"
  "      });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GT\", function(data) {\n"
  "      if(data.length >= 6) {\n"
  "        var year = parseInt(data[0]);\n"
  "        var month = parseInt(data[1]);\n"
  "        var day = parseInt(data[2]);\n"
  "        var hour = parseInt(data[3]);\n"
  "        var minute = parseInt(data[4]);\n"
  "        var second = parseInt(data[5]);\n"
  "\n"
  "        if(!isNaN(year) && !isNaN(month) && !isNaN(day) && !isNaN(hour) && !isNaN(minute) && !isNaN(second)) {\n"
  "          if (year==165 && month==165 && day==165 && hour==165 && minute==165 && second==85){\n"
  "            callback(new Date(0), false);//this pattern occurs when no RTC is connected to openevse\n"
  "          } else {\n"
  "            var date = new Date(2000+year, month - 1, day, hour, minute, second);\n"
  "            callback(date,true);\n"
  "          }\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse time \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Set or get the charge timer\n"
  "   *\n"
  "   * Argument:\n"
  "   *  - start: The start time\n"
  "   *  - end: The stop time\n"
  "   *\n"
  "   * If any of the values is false, get the timer\n"
  "   */\n"
  "  self.timer = function(callback, start = false, stop = false)\n"
  "  {\n"
  "    function addZero(val) {\n"
  "      return (val < 10 ? \"0\" : \"\") + val;\n"
  "    }\n"
  "\n"
  "    if(false !== start && false !== stop) {\n"
  "      var timeRegex = /([01]\\d|2[0-3]):([0-5]\\d)/;\n"
  "      var startArray = start.match(timeRegex);\n"
  "      var stopArray = stop.match(timeRegex);\n"
  "\n"
  "      if(null !== startArray && null !== stopArray)\n"
  "      {\n"
  "        return self._request([\n"
  "          \"ST\",\n"
  "          parseInt(startArray[1]), parseInt(startArray[2]),\n"
  "          parseInt(stopArray[1]), parseInt(stopArray[2])\n"
  "        ], function() {\n"
  "          self.timer(callback);\n"
  "        });\n"
  "      }\n"
  "\n"
  "      return false;\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GD\", function(data) {\n"
  "      if(data.length >= 4) {\n"
  "        var startMinute = parseInt(data[0]);\n"
  "        var startSecond = parseInt(data[1]);\n"
  "        var stopMinute = parseInt(data[2]);\n"
  "        var stopSecond = parseInt(data[3]);\n"
  "\n"
  "        if(!isNaN(startMinute) && !isNaN(startSecond) && !isNaN(stopMinute) && !isNaN(stopSecond)) {\n"
  "          if(0 === startMinute && 0 === startSecond && 0 === stopMinute && 0 === stopSecond) {\n"
  "            callback(false, \"--:--\", \"--:--\");\n"
  "          } else {\n"
  "            start = addZero(startMinute) + \":\" + addZero(startSecond);\n"
  "            stop = addZero(stopMinute) + \":\" + addZero(stopSecond);\n"
  "\n"
  "            callback(true, start, stop);\n"
  "          }\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse time \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Cancel the timer\n"
  "   */\n"
  "  self.cancelTimer = function (callback) {\n"
  "    return self._request([\n"
  "      \"ST\", 0, 0, 0, 0], function() {\n"
  "      callback();\n"
  "    });\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Get or set the charge time limit, in minutes.\n"
  "   *\n"
  "   * This time is rounded to the nearest quarter hour.\n"
  "   *\n"
  "   * The maximum value is 3825 minutes.\n"
  "   *\n"
  "   * Returns the limit\n"
  "   */\n"
  "  self.time_limit = function(callback, limit = false) {\n"
  "    if(false !== limit) {\n"
  "      return self._request([\"S3\", Math.round(limit/15.0)],\n"
  "        function() {\n"
  "          self.time_limit(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"G3\", function(data) {\n"
  "      if(data.length >= 1) {\n"
  "        var limit = parseInt(data[0]);\n"
  "\n"
  "        if(!isNaN(limit)) {\n"
  "          callback(limit * 15);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Get or set the charge limit, in kWh.\n"
  "   *\n"
  "   * 0 = no charge limit\n"
  "   *\n"
  "   * Returns the limit\n"
  "   */\n"
  "  self.charge_limit = function(callback, limit = false) {\n"
  "    if(false !== limit) {\n"
  "      return self._request([\"SH\", limit],\n"
  "        function() {\n"
  "          self.charge_limit(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GH\", function(data) {\n"
  "      if(data.length >= 1) {\n"
  "        var limit = parseInt(data[0]);\n"
  "\n"
  "        if(!isNaN(limit)) {\n"
  "          callback(limit);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Set or get the ammeter settings\n"
  "   *\n"
  "   * If either of the arguments is None, get the values instead of setting them.\n"
  "   *\n"
  "   * Returns scale factor and offset\n"
  "   */\n"
  "  self.ammeter_settings = function(callback, scaleFactor = false, offset = false) {\n"
  "    if(false !== scaleFactor && false !== offset) {\n"
  "      return self._request([\"SA\", scaleFactor, offset],\n"
  "        function() {\n"
  "          callback(scaleFactor, offset);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GA\", function(data) {\n"
  "      if(data.length >= 2) {\n"
  "        var scaleFactor = parseInt(data[0]);\n"
  "        var offset = parseInt(data[1]);\n"
  "\n"
  "        if(!isNaN(scaleFactor) && !isNaN(offset)) {\n"
  "          callback(scaleFactor, offset);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Set or get the current capacity\n"
  "   *\n"
  "   * If capacity is false, get the value\n"
  "   *\n"
  "   * Returns the capacity in amperes\n"
  "   */\n"
  "  self.current_capacity = function(callback, capacity = false) {\n"
  "    if(false !== capacity) {\n"
  "      return self._request([\"SC\", capacity],\n"
  "        function() {\n"
  "          self.current_capacity(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GE\", function(data) {\n"
  "      if(data.length >= 1) {\n"
  "        var capacity = parseInt(data[0]);\n"
  "\n"
  "        if(!isNaN(capacity)) {\n"
  "          callback(capacity);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Set or get the service level\n"
  "   *\n"
  "   * Allowed values:\n"
  "   * - 0: Auto\n"
  "   * - 1: Level 1, 120VAC 16A\n"
  "   * - 2: Level 2, 208-240VAC 80A\n"
  "   *\n"
  "   * If the level is not specified, the current level is returned\n"
  "   *\n"
  "   * Returns the current service level: 0 for auto, 1 or 2\n"
  "   */\n"
  "  self.service_level = function(callback, level = false) {\n"
  "    if(false !== level) {\n"
  "      return self._request([\"SL\", self._service_levels[level]],\n"
  "        function() {\n"
  "          self.service_level(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.auto_service_level ? 0 : flags.service_level, flags.service_level);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Get the current capacity range, in amperes\n"
  "   * (it depends on the service level)\n"
  "   * Returns the current capacity:\n"
  "   *     (min_capacity, max_capacity)\n"
  "   */\n"
  "  self.current_capacity_range = function(callback) {\n"
  "    var request = self._request(\"GC\", function(data) {\n"
  "      if(data.length >= 2) {\n"
  "        var minCapacity = parseInt(data[0]);\n"
  "        var maxCapacity = parseInt(data[1]);\n"
  "        if(!isNaN(minCapacity) && !isNaN(maxCapacity)) {\n"
  "          callback(minCapacity, maxCapacity);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * Change the EVSE status.\n"
  "   *\n"
  "   * If an action is not specified, the status is requested\n"
  "   *\n"
  "   * Allowed actions:\n"
  "   *   * enable\n"
  "   *   * disable\n"
  "   *   * sleep\n"
  "   *\n"
  "   * Default: no action, request the status\n"
  "   *\n"
  "   * Returns the status of the EVSE as a string\n"
  "   *\n"
  "   */\n"
  "  self.status = function(callback, action = false) {\n"
  "    if(false !== action) {\n"
  "      var cmd = self._status_functions[action];\n"
  "      return self._request([cmd],\n"
  "        function() {\n"
  "          self.status(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GS\", function(data) {\n"
  "      if(data.length >= 1) {\n"
  "        var state = parseInt(data[0]);\n"
  "        var elapsed = parseInt(data[1]);\n"
  "\n"
  "        if(!isNaN(state) && !isNaN(elapsed)) {\n"
  "          callback(state, elapsed);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable the diode check\n"
  "   * if enabled == False, disable the diode check\n"
  "   * if enabled is not specified, request the diode check status\n"
  "   *\n"
  "   * Returns the diode check status\n"
  "   */\n"
  "  self.diode_check = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF\", \"D\", enabled ? \"1\" : \"0\"],\n"
  "      // OLD API < 4.0.1\n"
  "      // return self._request([\"SD\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.diode_check(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.diode_check);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable the GFI self test\n"
  "   * if enabled == False, disable the GFI self test\n"
  "   * if enabled is not specified, request the GFI self test status\n"
  "   *\n"
  "   * Returns the GFI self test status\n"
  "   */\n"
  "  self.gfi_self_test = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF F\", enabled ? \"1\" : \"0\"],\n"
  "      // OLD API < 4.0.1\n"
  "      // return self._request([\"SF\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.gfi_self_test(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.gfi_self_test);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable the ground check\n"
  "   * if enabled == False, disable the ground check\n"
  "   * if enabled is not specified, request the ground check status\n"
  "   *\n"
  "   * Returns the ground check status\n"
  "   */\n"
  "  self.ground_check = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF G\", enabled ? \"1\" : \"0\"],\n"
  "      // OLD API < 4.0.1\n"
  "      // return self._request([\"SG\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.ground_check(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.ground_check);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable the stuck relay check\n"
  "   * if enabled == False, disable the stuck relay check\n"
  "   * if enabled is not specified, request the stuck relay check status\n"
  "   *\n"
  "   * Returns the stuck relay check status\n"
  "   */\n"
  "  self.stuck_relay_check = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF R\", enabled ? \"1\" : \"0\"],\n"
  "      // OLD API < 4.0.1\n"
  "      // return self._request([\"SR\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.stuck_relay_check(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.stuck_relay_check);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable \"ventilation required check\"\n"
  "   * if enabled == False, disable \"ventilation required check\"\n"
  "   * if enabled is not specified, request the \"ventilation required check\" status\n"
  "   *\n"
  "   * Returns the \"ventilation required\" status\n"
  "   */\n"
  "  self.vent_required = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF V\", enabled ? \"1\" : \"0\"],\n"
  "      // OLD API < 4.0.1\n"
  "      // return self._request([\"SV\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.vent_required(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.vent_required);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   * if enabled == True, enable \"temperature monitoring\"\n"
  "   * if enabled == False, disable \"temperature monitoring\"\n"
  "   * if enabled is not specified, request the \"temperature monitoring\" status\n"
  "   *\n"
  "   * Returns the \"temperature monitoring\" status\n"
  "   */\n"
  "\n"
  "  self.temp_check = function(callback, enabled = null) {\n"
  "    if(null !== enabled) {\n"
  "      return self._request([\"FF T\", enabled ? \"1\" : \"0\"],\n"
  "        function() {\n"
  "          self.temp_check(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._flags(function(flags) {\n"
  "      callback(flags.temp_check);\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "\n"
  "  // OLD API < 4.0.1\n"
  "  // self.temp_check = function(callback, enabled = null) {\n"
  "  //   if(null !== enabled)\n"
  "  //   {\n"
  "  //     if(enabled)\n"
  "  //     {\n"
  "  //       return self._request(\"GO\", function(data) {\n"
  "  //         self._request([\"SO\", data[0], data[1]],\n"
  "  //           function() {\n"
  "  //             self.temp_check(callback);\n"
  "  //           });\n"
  "  //       });\n"
  "  //     }\n"
  "  // **NOTE: SO has been removed totally in RAPI 4.0.0**\n"
  "  //     return self._request([\"SO\", \"0\", \"0\"],\n"
  "  //       function() {\n"
  "  //         self.temp_check(callback);\n"
  "  //       });\n"
  "  //   }\n"
  "  //   var request = self._flags(function(flags) {\n"
  "  //     callback(flags.temp_check);\n"
  "  //   });\n"
  "  //   return request;\n"
  "  // };\n"
  "\n"
  "\n"
  "\n"
  "  /**\n"
  "   *\n"
  "   */\n"
  "  self.over_temperature_thresholds = function(callback, ambientthresh = false, irthresh = false) {\n"
  "    if(false !== ambientthresh && false !== irthresh) {\n"
  "      return self._request([\"SO\", ambientthresh, irthresh],\n"
  "        function() {\n"
  "          self.over_temperature_thresholds(callback);\n"
  "        });\n"
  "    }\n"
  "\n"
  "    var request = self._request(\"GO\", function(data) {\n"
  "      if(data.length >= 2) {\n"
  "        var ambientthresh = parseInt(data[0]);\n"
  "        var irthresh = parseInt(data[1]);\n"
  "\n"
  "        if(!isNaN(ambientthresh) && !isNaN(irthresh)) {\n"
  "          callback(ambientthresh, irthresh);\n"
  "        } else {\n"
  "          request._error(new OpenEVSEError(\"ParseError\", \"Could not parse \\\"\"+data.join(\" \")+\"\\\" arguments\"));\n"
  "        }\n"
  "      } else {\n"
  "        request._error(new OpenEVSEError(\"ParseError\", \"Only received \"+data.length+\" arguments\"));\n"
  "      }\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  /**\n"
  "   *\n"
  "   */\n"
  "  self.press_button = function(callback) {\n"
  "    var request = self._request(\"F1\", function() {\n"
  "      callback();\n"
  "    });\n"
  "    return request;\n"
  "  };\n"
  "\n"
  "  self.setEndpoint = function (endpoint) {\n"
  "    self._endpoint = endpoint;\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global $, ko */\n"
  "/* exported RapiViewModel */\n"
  "\n"
  "function RapiViewModel(baseEndpoint) {\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "\n"
  "  self.baseEndpoint = baseEndpoint;\n"
  "\n"
  "  self.rapiSend = ko.observable(false);\n"
  "  self.cmd = ko.observable(\"\");\n"
  "  self.ret = ko.observable(\"\");\n"
  "\n"
  "  self.send = function() {\n"
  "    self.rapiSend(true);\n"
  "    $.get(self.baseEndpoint() + \"/r?json=1&rapi=\"+encodeURI(self.cmd()), function (data) {\n"
  "      self.ret(\">\"+data.ret);\n"
  "      self.cmd(data.cmd);\n"
  "    }, \"json\").always(function () {\n"
  "      self.rapiSend(false);\n"
  "    });\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global ko */\n"
  "/* exported TimeViewModel */\n"
  "\n"
  "function TimeViewModel(openevse)\n"
  "{\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "\n"
  "  function addZero(val) {\n"
  "    return (val < 10 ? \"0\" : \"\") + val;\n"
  "  }\n"
  "\n"
  "  function startTimeUpdate() {\n"
  "    timeUpdateTimeout = setInterval(function () {\n"
  "      if(self.automaticTime()) {\n"
  "        self.nowTimedate(new Date(self.evseTimedate().getTime() + ((new Date()) - self.localTimedate())));\n"
  "      }\n"
  "      if(openevse.isCharging()) {\n"
  "        self.elapsedNow(new Date((openevse.status.elapsed() * 1000) + ((new Date()) - self.elapsedLocal())));\n"
  "      }\n"
  "      /*if(openevse.isEcoModeAvailable())*/ {\n"
  "        self.divertUpdateNow(new Date((openevse.status.divert_update() * 1000) + ((new Date()) - self.divertUpdateLocal())));\n"
  "      }\n"
  "    }, 1000);\n"
  "  }\n"
  "\n"
  "  function stopTimeUpdate() {\n"
  "    if(null !== timeUpdateTimeout) {\n"
  "      clearInterval(timeUpdateTimeout);\n"
  "      timeUpdateTimeout = null;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  self.evseTimedate = ko.observable(new Date());\n"
  "  self.localTimedate = ko.observable(new Date());\n"
  "  self.nowTimedate = ko.observable(null);\n"
  "  self.hasRTC= ko.observable(true);\n"
  "  self.elapsedNow = ko.observable(new Date(0));\n"
  "  self.elapsedLocal = ko.observable(new Date());\n"
  "  self.divertUpdateNow = ko.observable(new Date(0));\n"
  "  self.divertUpdateLocal = ko.observable(new Date());\n"
  "\n"
  "  self.date = ko.pureComputed({\n"
  "    read: function () {\n"
  "      if(null === self.nowTimedate()) {\n"
  "        return \"\";\n"
  "      }\n"
  "\n"
  "      var dt = self.nowTimedate();\n"
  "      return (dt.getFullYear())+\"-\"+addZero(dt.getMonth() + 1)+\"-\"+addZero(dt.getDate());\n"
  "    },\n"
  "    write: function (val) {\n"
  "      var dt = self.evseTimedate();\n"
  "      val += \" \" + addZero(dt.getHours())+\":\"+addZero(dt.getMinutes())+\":\"+addZero(dt.getSeconds());\n"
  "      self.evseTimedate(new Date(val));\n"
  "      self.localTimedate(new Date());\n"
  "    }});\n"
  "\n"
  "  self.time = ko.pureComputed({\n"
  "    read: function () {\n"
  "      if(null === self.nowTimedate()) {\n"
  "        return \"--:--:--\";\n"
  "      }\n"
  "      var dt = self.nowTimedate();\n"
  "      return addZero(dt.getHours())+\":\"+addZero(dt.getMinutes())+\":\"+addZero(dt.getSeconds());\n"
  "    },\n"
  "    write: function (val) {\n"
  "      var parts = val.split(\":\");\n"
  "      var date = self.evseTimedate();\n"
  "      date.setHours(parseInt(parts[0]));\n"
  "      date.setMinutes(parseInt(parts[1]));\n"
  "      self.evseTimedate(date);\n"
  "      self.localTimedate(new Date());\n"
  "    }});\n"
  "\n"
  "  self.elapsed = ko.pureComputed(function () {\n"
  "    if(null === self.nowTimedate()) {\n"
  "      return \"0:00:00\";\n"
  "    }\n"
  "    var time = self.elapsedNow().getTime();\n"
  "    time = Math.floor(time / 1000);\n"
  "    var seconds = time % 60;\n"
  "    time = Math.floor(time / 60);\n"
  "    var minutes = time % 60;\n"
  "    var hours = Math.floor(time / 60);\n"
  "    return hours+\":\"+addZero(minutes)+\":\"+addZero(seconds);\n"
  "  });\n"
  "\n"
  "  openevse.status.elapsed.subscribe(function (val) {\n"
  "    self.elapsedNow(new Date(val * 1000));\n"
  "    self.elapsedLocal(new Date());\n"
  "  });\n"
  "\n"
  "  self.divert_update = ko.pureComputed(function () {\n"
  "    if(null === self.nowTimedate()) {\n"
  "      return false;\n"
  "    }\n"
  "    var time = self.divertUpdateNow().getTime();\n"
  "    return Math.floor(time / 1000);\n"
  "  });\n"
  "\n"
  "  openevse.status.divert_update.subscribe(function (val) {\n"
  "    self.divertUpdateNow(new Date(val * 1000));\n"
  "    self.divertUpdateLocal(new Date());\n"
  "  });\n"
  "\n"
  "  var timeUpdateTimeout = null;\n"
  "  self.automaticTime = ko.observable(true);\n"
  "\n"
  "  self.timeUpdate = function (date,valid=true) {\n"
  "    self.hasRTC(valid);\n"
  "    stopTimeUpdate();\n"
  "    self.evseTimedate(date);\n"
  "    self.nowTimedate(date);\n"
  "    self.localTimedate(new Date());\n"
  "    startTimeUpdate();\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global ko, BaseViewModel */\n"
  "\n"
  "function TimeZoneViewModel(data)\n"
  "{\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "\n"
  "  self.name = ko.observable(data.name);\n"
  "  self.value = ko.observable(data.name+\"|\"+data.tz);\n"
  "}\n"
  "\n"
  "function ZonesViewModel(baseEndpoint) {\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "  var endpoint = ko.pureComputed(function () { return baseEndpoint() + \"/zones.json\"; });\n"
  "\n"
  "  // Observable properties\n"
  "  self.fetching = ko.observable(false);\n"
  "  self.zones = ko.mapping.fromJS([], {\n"
  "    key: function(data) {\n"
  "      return ko.utils.unwrapObservable(data.name);\n"
  "    },\n"
  "    create: function (options) {\n"
  "      return new TimeZoneViewModel(options.data);\n"
  "    }\n"
  "  });\n"
  "\n"
  "  self.initialValue = function (val) {\n"
  "    var parts = val.split(\"|\", 2);\n"
  "    if(2 == parts.length)\n"
  "    {\n"
  "      self.zones.push(new TimeZoneViewModel({\n"
  "        name: parts[0],\n"
  "        tz: parts[1]\n"
  "      }));\n"
  "    }\n"
  "    else\n"
  "    {\n"
  "      self.zones.push(new TimeZoneViewModel({\n"
  "        name: \"Default\",\n"
  "        tz: parts[1]\n"
  "      }));\n"
  "    }\n"
  "  };\n"
  "\n"
  "  self.update = function (after = function () { }) {\n"
  "    self.fetching(true);\n"
  "    $.get(endpoint(), function (data) {\n"
  "      var zones = [];\n"
  "      for (const name in data) {\n"
  "        if (data.hasOwnProperty(name)) {\n"
  "          zones.push({name:name, tz:data[name]});\n"
  "        }\n"
  "      }\n"
  "\n"
  "      ko.mapping.fromJS(zones, self.zones);\n"
  "    }, \"json\").always(function () {\n"
  "      self.fetching(false);\n"
  "      after();\n"
  "    });\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global ko, OpenEVSE, TimeViewModel */\n"
  "/* exported OpenEvseViewModel */\n"
  "\n"
  "\n"
  "function DummyRequest()\n"
  "{\n"
  "  var self = this;\n"
  "  self.always = function(fn) {\n"
  "    fn();\n"
  "    return self;\n"
  "  };\n"
  "}\n"
  "\n"
  "function OpenEvseViewModel(baseEndpoint, configViewModel, statusViewModel) {\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "  var endpoint = ko.pureComputed(function () { return baseEndpoint() + \"/r\"; });\n"
  "  self.openevse = new OpenEVSE(endpoint());\n"
  "  endpoint.subscribe(function (end) {\n"
  "    self.openevse.setEndpoint(end);\n"
  "  });\n"
  "  self.status = statusViewModel;\n"
  "  self.config = configViewModel;\n"
  "  self.time = new TimeViewModel(self);\n"
  "\n"
  "  // Option lists\n"
  "  self.serviceLevels = [\n"
  "    { name: \"Auto\", value: 0 },\n"
  "    { name: \"1\", value: 1 },\n"
  "    { name: \"2\", value: 2 }];\n"
  "  self.currentLevels = ko.observableArray([]);\n"
  "  self.timeLimits = [\n"
  "    { name: \"none\", value: 0 },\n"
  "    { name: \"15 min\", value: 15 },\n"
  "    { name: \"30 min\", value: 30 },\n"
  "    { name: \"45 min\", value: 45 },\n"
  "    { name: \"1 hour\", value: 60 },\n"
  "    { name: \"1.5 hours\", value: 1.5 * 60 },\n"
  "    { name: \"2 hours\", value: 2 * 60 },\n"
  "    { name: \"2.5 hours\", value: 2.5 * 60 },\n"
  "    { name: \"3 hours\", value: 3 * 60 },\n"
  "    { name: \"4 hours\", value: 4 * 60 },\n"
  "    { name: \"5 hours\", value: 5 * 60 },\n"
  "    { name: \"6 hours\", value: 6 * 60 },\n"
  "    { name: \"7 hours\", value: 7 * 60 },\n"
  "    { name: \"8 hours\", value: 8 * 60 }];\n"
  "\n"
  "  self.chargeLimits = [\n"
  "    { name: \"none\", value: 0 },\n"
  "    { name: \"1 kWh\", value: 1 },\n"
  "    { name: \"2 kWh\", value: 2 },\n"
  "    { name: \"3 kWh\", value: 3 },\n"
  "    { name: \"4 kWh\", value: 4 },\n"
  "    { name: \"5 kWh\", value: 5 },\n"
  "    { name: \"6 kWh\", value: 6 },\n"
  "    { name: \"7 kWh\", value: 7 },\n"
  "    { name: \"8 kWh\", value: 8 },\n"
  "    { name: \"9 kWh\", value: 9 },\n"
  "    { name: \"10 kWh\", value: 10 },\n"
  "    { name: \"15 kWh\", value: 11 },\n"
  "    { name: \"20 kWh\", value: 12 },\n"
  "    { name: \"25 kWh\", value: 25 },\n"
  "    { name: \"30 kWh\", value: 30 },\n"
  "    { name: \"35 kWh\", value: 35 },\n"
  "    { name: \"40 kWh\", value: 40 },\n"
  "    { name: \"45 kWh\", value: 45 },\n"
  "    { name: \"50 kWh\", value: 50 },\n"
  "    { name: \"55 kWh\", value: 55 },\n"
  "    { name: \"60 kWh\", value: 60 },\n"
  "    { name: \"70 kWh\", value: 70 },\n"
  "    { name: \"80 kWh\", value: 80 },\n"
  "    { name: \"90 kWh\", value: 90 }];\n"
  "\n"
  "  self.serviceLevel = ko.observable(-1);\n"
  "  self.actualServiceLevel = ko.observable(-1);\n"
  "  self.minCurrentLevel = ko.observable(-1);\n"
  "  self.maxCurrentLevel = ko.observable(-1);\n"
  "  self.currentCapacity = ko.observable(-1);\n"
  "  self.timeLimit = ko.observable(-1);\n"
  "  self.chargeLimit = ko.observable(-1);\n"
  "  self.delayTimerEnabled = ko.observable(false);\n"
  "  self.delayTimerStart = ko.observable(\"--:--\");\n"
  "  self.delayTimerStop = ko.observable(\"--:--\");\n"
  "\n"
  "  // Saftey tests\n"
  "  self.gfiSelfTestEnabled = ko.observable(false);\n"
  "  self.groundCheckEnabled = ko.observable(false);\n"
  "  self.stuckRelayEnabled = ko.observable(false);\n"
  "  self.tempCheckEnabled = ko.observable(false);\n"
  "  self.diodeCheckEnabled = ko.observable(false);\n"
  "  self.ventRequiredEnabled = ko.observable(false);\n"
  "  self.allTestsEnabled = ko.pureComputed(function () {\n"
  "    return self.gfiSelfTestEnabled() &&\n"
  "           self.groundCheckEnabled() &&\n"
  "           self.stuckRelayEnabled() &&\n"
  "           self.tempCheckEnabled() &&\n"
  "           self.diodeCheckEnabled() &&\n"
  "           self.ventRequiredEnabled();\n"
  "  });\n"
  "\n"
  "  self.tempCheckSupported = ko.observable(false);\n"
  "\n"
  "  // Derived states\n"
  "  self.isConnected = ko.pureComputed(function () {\n"
  "    return [2, 3].indexOf(self.status.state()) !== -1;\n"
  "  });\n"
  "\n"
  "  self.isReady = ko.pureComputed(function () {\n"
  "    return [0, 1].indexOf(self.status.state()) !== -1;\n"
  "  });\n"
  "\n"
  "  self.isCharging = ko.pureComputed(function () {\n"
  "    return 3 === self.status.state();\n"
  "  });\n"
  "\n"
  "  self.isError = ko.pureComputed(function () {\n"
  "    return [4, 5, 6, 7, 8, 9, 10, 11].indexOf(self.status.state()) !== -1;\n"
  "  });\n"
  "\n"
  "  self.isEnabled = ko.pureComputed(function () {\n"
  "    return [0, 1, 2, 3].indexOf(self.status.state()) !== -1;\n"
  "  });\n"
  "\n"
  "  self.isSleeping = ko.pureComputed(function () {\n"
  "    return 254 === self.status.state();\n"
  "  });\n"
  "\n"
  "  self.isDisabled = ko.pureComputed(function () {\n"
  "    return 255 === self.status.state();\n"
  "  });\n"
  "\n"
  "  self.isPaused = ko.pureComputed(function () {\n"
  "    return [254, 255].indexOf(self.status.state()) !== -1;\n"
  "  });\n"
  "\n"
  "  // helper to select an appropriate value for time limit\n"
  "  self.selectTimeLimit = function(limit)\n"
  "  {\n"
  "    if(self.timeLimit() === limit) {\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    for(var i = 0; i < self.timeLimits.length; i++) {\n"
  "      var time = self.timeLimits[i];\n"
  "      if(time.value >= limit) {\n"
  "        self.timeLimit(time.value);\n"
  "        break;\n"
  "      }\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // helper to select an appropriate value for charge limit\n"
  "  self.selectChargeLimit = function(limit)\n"
  "  {\n"
  "    if(self.chargeLimit() === limit) {\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    for(var i = 0; i < self.chargeLimits.length; i++) {\n"
  "      var charge = self.chargeLimits[i];\n"
  "      if(charge.value >= limit) {\n"
  "        self.chargeLimit(charge.value);\n"
  "        break;\n"
  "      }\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // List of items to update on calling update(). The list will be processed one item at\n"
  "  // a time.\n"
  "  var updateList = [\n"
  "    function () { \n"
  "      if(false === self.status.time()) {\n"
  "        return self.openevse.time(self.time.timeUpdate);\n"
  "      }\n"
  "      return new DummyRequest();\n"
  "    },\n"
  "    function () { return self.openevse.service_level(function (level, actual) {\n"
  "      self.serviceLevel(level);\n"
  "      self.actualServiceLevel(actual);\n"
  "    }); },\n"
  "    function () { return self.updateCurrentCapacity(); },\n"
  "    function () { return self.openevse.current_capacity(function (capacity) {\n"
  "      self.currentCapacity(capacity);\n"
  "    }); },\n"
  "    function () { return self.openevse.time_limit(function (limit) {\n"
  "      self.selectTimeLimit(limit);\n"
  "    }); },\n"
  "    function () { return self.openevse.charge_limit(function (limit) {\n"
  "      self.selectChargeLimit(limit);\n"
  "    }); },\n"
  "    function () { return self.openevse.gfi_self_test(function (enabled) {\n"
  "      self.gfiSelfTestEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.ground_check(function (enabled) {\n"
  "      self.groundCheckEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.stuck_relay_check(function (enabled) {\n"
  "      self.stuckRelayEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.temp_check(function (enabled) {\n"
  "      self.tempCheckEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.diode_check(function (enabled) {\n"
  "      self.diodeCheckEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.vent_required(function (enabled) {\n"
  "      self.ventRequiredEnabled(enabled);\n"
  "    }); },\n"
  "    function () { return self.openevse.temp_check(function () {\n"
  "      self.tempCheckSupported(true);\n"
  "    }, self.tempCheckEnabled()).error(function () {\n"
  "      self.tempCheckSupported(false);\n"
  "    }); },\n"
  "    function () { return self.openevse.timer(function (enabled, start, stop) {\n"
  "      self.delayTimerEnabled(enabled);\n"
  "      self.delayTimerStart(start);\n"
  "      self.delayTimerStop(stop);\n"
  "    }); },\n"
  "  ];\n"
  "  self.updateCount = ko.observable(0);\n"
  "  self.updateTotal = ko.observable(updateList.length);\n"
  "\n"
  "  self.updateCurrentCapacity = function () {\n"
  "    return self.openevse.current_capacity_range(function (min, max) {\n"
  "      self.minCurrentLevel(min);\n"
  "      self.maxCurrentLevel(max);\n"
  "      var capacity = self.currentCapacity();\n"
  "      self.currentLevels.removeAll();\n"
  "      for(var i = self.minCurrentLevel(); i <= self.maxCurrentLevel(); i++) {\n"
  "        self.currentLevels.push({name: i+\" A\", value: i});\n"
  "      }\n"
  "      self.currentCapacity(capacity);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  self.updatingServiceLevel = ko.observable(false);\n"
  "  self.savedServiceLevel = ko.observable(false);\n"
  "  self.updatingCurrentCapacity = ko.observable(false);\n"
  "  self.savedCurrentCapacity = ko.observable(false);\n"
  "  self.updatingTimeLimit = ko.observable(false);\n"
  "  self.savedTimeLimit = ko.observable(false);\n"
  "  self.updatingChargeLimit = ko.observable(false);\n"
  "  self.savedChargeLimit = ko.observable(false);\n"
  "  self.updatingDelayTimer = ko.observable(false);\n"
  "  self.savedDelayTimer = ko.observable(false);\n"
  "  self.updatingStatus = ko.observable(false);\n"
  "  self.savedStatus = ko.observable(false);\n"
  "  self.updatingGfiSelfTestEnabled = ko.observable(false);\n"
  "  self.savedGfiSelfTestEnabled = ko.observable(false);\n"
  "  self.updatingGroundCheckEnabled = ko.observable(false);\n"
  "  self.savedGroundCheckEnabled = ko.observable(false);\n"
  "  self.updatingStuckRelayEnabled = ko.observable(false);\n"
  "  self.savedStuckRelayEnabled = ko.observable(false);\n"
  "  self.updatingTempCheckEnabled = ko.observable(false);\n"
  "  self.savedTempCheckEnabled = ko.observable(false);\n"
  "  self.updatingDiodeCheckEnabled = ko.observable(false);\n"
  "  self.savedDiodeCheckEnabled = ko.observable(false);\n"
  "  self.updatingVentRequiredEnabled = ko.observable(false);\n"
  "  self.savedVentRequiredEnabled = ko.observable(false);\n"
  "\n"
  "  self.setForTime = function (flag, time) {\n"
  "    flag(true);\n"
  "    setTimeout(function () { flag(false); }, time);\n"
  "  };\n"
  "\n"
  "  var subscribed = false;\n"
  "  self.subscribe = function ()\n"
  "  {\n"
  "    if(subscribed) {\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    // Updates to the service level\n"
  "    self.serviceLevel.subscribe(function (val) {\n"
  "      self.updatingServiceLevel(true);\n"
  "      self.openevse.service_level(function (level, actual) {\n"
  "        self.setForTime(self.savedServiceLevel, 2000);\n"
  "        self.actualServiceLevel(actual);\n"
  "        self.updateCurrentCapacity().always(function () {\n"
  "        });\n"
  "      }, val).always(function() {\n"
  "        self.updatingServiceLevel(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the current capacity\n"
  "    self.currentCapacity.subscribe(function (val) {\n"
  "      if(true === self.updatingServiceLevel()) {\n"
  "        return;\n"
  "      }\n"
  "      self.updatingCurrentCapacity(true);\n"
  "      self.openevse.current_capacity(function (capacity) {\n"
  "        self.setForTime(self.savedCurrentCapacity, 2000);\n"
  "        if(val !== capacity) {\n"
  "          self.currentCapacity(capacity);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingCurrentCapacity(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the time limit\n"
  "    self.timeLimit.subscribe(function (val) {\n"
  "      self.updatingTimeLimit(true);\n"
  "      self.openevse.time_limit(function (limit) {\n"
  "        self.setForTime(self.savedTimeLimit, 2000);\n"
  "        if(val !== limit) {\n"
  "          self.selectTimeLimit(limit);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingTimeLimit(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the charge limit\n"
  "    self.chargeLimit.subscribe(function (val) {\n"
  "      self.updatingChargeLimit(true);\n"
  "      self.openevse.charge_limit(function (limit) {\n"
  "        self.setForTime(self.savedChargeLimit, 2000);\n"
  "        if(val !== limit) {\n"
  "          self.selectChargeLimit(limit);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingChargeLimit(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the GFI self test\n"
  "    self.gfiSelfTestEnabled.subscribe(function (val) {\n"
  "      self.updatingGfiSelfTestEnabled(true);\n"
  "      self.openevse.gfi_self_test(function (enabled) {\n"
  "        self.setForTime(self.savedGfiSelfTestEnabled, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.gfiSelfTestEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingGfiSelfTestEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the ground check\n"
  "    self.groundCheckEnabled.subscribe(function (val) {\n"
  "      self.updatingGroundCheckEnabled(true);\n"
  "      self.openevse.ground_check(function (enabled) {\n"
  "        self.setForTime(self.savedGroundCheckEnabled, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.groundCheckEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingGroundCheckEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the stuck relay check\n"
  "    self.stuckRelayEnabled.subscribe(function (val) {\n"
  "      self.updatingStuckRelayEnabled(true);\n"
  "      self.savedStuckRelayEnabled(false);\n"
  "      self.openevse.stuck_relay_check(function (enabled) {\n"
  "        self.savedStuckRelayEnabled(true);\n"
  "        setTimeout(function () { self.savedStuckRelayEnabled(false); }, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.stuckRelayEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingStuckRelayEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the temp check\n"
  "    self.tempCheckEnabled.subscribe(function (val) {\n"
  "      self.updatingTempCheckEnabled(true);\n"
  "      self.openevse.temp_check(function (enabled) {\n"
  "        self.setForTime(self.savedTempCheckEnabled, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.tempCheckEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingTempCheckEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the diode check\n"
  "    self.diodeCheckEnabled.subscribe(function (val) {\n"
  "      self.updatingDiodeCheckEnabled(true);\n"
  "      self.openevse.diode_check(function (enabled) {\n"
  "        self.setForTime(self.savedDiodeCheckEnabled, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.diodeCheckEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingDiodeCheckEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    // Updates to the vent required\n"
  "    self.ventRequiredEnabled.subscribe(function (val) {\n"
  "      self.updatingVentRequiredEnabled(true);\n"
  "      self.openevse.vent_required(function (enabled) {\n"
  "        self.setForTime(self.savedVentRequiredEnabled, 2000);\n"
  "        if(val !== enabled) {\n"
  "          self.ventRequiredEnabled(enabled);\n"
  "        }\n"
  "      }, val).always(function() {\n"
  "        self.updatingVentRequiredEnabled(false);\n"
  "      });\n"
  "    });\n"
  "\n"
  "    subscribed = true;\n"
  "  };\n"
  "\n"
  "  self.update = function (after = function () { }) {\n"
  "    self.updateCount(0);\n"
  "    self.nextUpdate(after);\n"
  "  };\n"
  "\n"
  "  self.nextUpdate = function (after) {\n"
  "    var updateFn = updateList[self.updateCount()];\n"
  "    updateFn().always(function () {\n"
  "      self.updateCount(self.updateCount() + 1);\n"
  "      if(self.updateCount() < updateList.length) {\n"
  "        self.nextUpdate(after);\n"
  "      } else {\n"
  "        self.subscribe();\n"
  "        after();\n"
  "      }\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // delay timer logic\n"
  "  function isTime(val) {\n"
  "    var timeRegex = /([01]\\d|2[0-3]):([0-5]\\d)/;\n"
  "    return timeRegex.test(val);\n"
  "  }\n"
  "  self.delayTimerValid = ko.pureComputed(function () {\n"
  "    return isTime(self.delayTimerStart()) && isTime(self.delayTimerStop());\n"
  "  });\n"
  "  self.startDelayTimer = function () {\n"
  "    self.updatingDelayTimer(true);\n"
  "    self.openevse.timer(function () {\n"
  "      self.delayTimerEnabled(true);\n"
  "    }, self.delayTimerStart(), self.delayTimerStop()).always(function() {\n"
  "      self.updatingDelayTimer(false);\n"
  "    });\n"
  "  };\n"
  "  self.stopDelayTimer = function () {\n"
  "    self.updatingDelayTimer(true);\n"
  "    self.openevse.cancelTimer(function () {\n"
  "      self.delayTimerEnabled(false);\n"
  "    }).always(function() {\n"
  "      self.updatingDelayTimer(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // support for changing status\n"
  "  self.setStatus = function (action)\n"
  "  {\n"
  "    if(\"pause\" === action) {\n"
  "      action = self.config.pause_uses_disabled() ? \"disable\" : \"sleep\";\n"
  "    }\n"
  "\n"
  "    var currentState = self.status.state();\n"
  "    if((\"disable\" === action && 255 === currentState) ||\n"
  "       (\"sleep\" === action && 254 === currentState) ||\n"
  "       (\"enable\" === action && currentState < 254))\n"
  "    {\n"
  "      // nothing to do\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    self.updatingStatus(true);\n"
  "    if(self.delayTimerEnabled() && (\"sleep\" === action || \"enable\" === action))\n"
  "    {\n"
  "      // If the delay Timer is enabled we have to do a bit of hackery to work around a\n"
  "      // firmware issue\n"
  "      //\n"
  "      // When in timer mode the RAPI cpmmands to change state might not work, but\n"
  "      // Emulating a button press does toggle between sleep/enable\n"
  "\n"
  "      self.openevse.press_button(function () {\n"
  "        action = false;\n"
  "      }).always(function () {\n"
  "        self.openevse.status(function (state) {\n"
  "          self.status.state(state);\n"
  "        }, action).always(function() {\n"
  "          self.updatingStatus(false);\n"
  "        });\n"
  "      });\n"
  "\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    self.openevse.status(function (state) {\n"
  "      self.status.state(state);\n"
  "    }, action).always(function() {\n"
  "      self.updatingStatus(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // Support for restarting the OpenEVSE\n"
  "  self.restartFetching = ko.observable(false);\n"
  "  self.restart = function() {\n"
  "    if (confirm(\"Restart OpenEVSE? Current config will be saved, takes approximately 10s.\")) {\n"
  "      self.restartFetching(true);\n"
  "      self.openevse.reset().always(function () {\n"
  "        self.restartFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global $, ko, ConfigViewModel, StatusViewModel, RapiViewModel, WiFiScanViewModel, WiFiConfigViewModel, OpenEvseViewModel, PasswordViewModel, ZonesViewModel, ConfigGroupViewModel, ScheduleViewModel */\n"
  "/* exported OpenEvseWiFiViewModel */\n"
  "\n"
  "function OpenEvseWiFiViewModel(baseHost, basePort, baseProtocol)\n"
  "{\n"
  "  \"use strict\";\n"
  "  var self = this;\n"
  "\n"
  "  self.baseHost = ko.observable(\"\" !== baseHost ? baseHost : \"openevse.local\");\n"
  "  self.basePort = ko.observable(basePort);\n"
  "  self.baseProtocol = ko.observable(baseProtocol);\n"
  "\n"
  "  self.baseEndpoint = ko.pureComputed(function () {\n"
  "    var endpoint = \"//\" + self.baseHost();\n"
  "    if(80 !== self.basePort()) {\n"
  "      endpoint += \":\"+self.basePort();\n"
  "    }\n"
  "    return endpoint;\n"
  "  });\n"
  "\n"
  "  self.wsEndpoint = ko.pureComputed(function () {\n"
  "    var endpoint = \"ws://\" + self.baseHost();\n"
  "    if(\"https:\" === self.baseProtocol()){\n"
  "      endpoint = \"wss://\" + self.baseHost();\n"
  "    }\n"
  "    if(80 !== self.basePort()) {\n"
  "      endpoint += \":\"+self.basePort();\n"
  "    }\n"
  "    endpoint += \"/ws\";\n"
  "    return endpoint;\n"
  "  });\n"
  "\n"
  "  self.config = new ConfigViewModel(self.baseEndpoint);\n"
  "  self.status = new StatusViewModel(self.baseEndpoint);\n"
  "  self.rapi = new RapiViewModel(self.baseEndpoint);\n"
  "  self.scan = new WiFiScanViewModel(self.baseEndpoint);\n"
  "  self.wifi = new WiFiConfigViewModel(self.baseEndpoint, self.config, self.status, self.scan);\n"
  "  self.openevse = new OpenEvseViewModel(self.baseEndpoint, self.config, self.status);\n"
  "  self.zones = new ZonesViewModel(self.baseEndpoint);\n"
  "  self.schedule = new ScheduleViewModel(self.baseEndpoint);\n"
  "\n"
  "  self.initialised = ko.observable(false);\n"
  "  self.updating = ko.observable(false);\n"
  "  self.scanUpdating = ko.observable(false);\n"
  "\n"
  "  self.wifi.selectedNet.subscribe((net) => {\n"
  "    if(false !== net) {\n"
  "      self.config.ssid(net.ssid());\n"
  "    }\n"
  "  });\n"
  "\n"
  "  self.config.ssid.subscribe((ssid) => {\n"
  "    self.wifi.setSsid(ssid);\n"
  "  });\n"
  "\n"
  "  // Info text display state\n"
  "  self.showMqttInfo = ko.observable(false);\n"
  "  self.showSolarDivert = ko.observable(false);\n"
  "  self.showSafety = ko.observable(false);\n"
  "  self.showVehiclePauseStatus = ko.observable(false);\n"
  "\n"
  "  self.toggle = function (flag) {\n"
  "    flag(!flag());\n"
  "  };\n"
  "\n"
  "  // Advanced mode\n"
  "  self.advancedMode = ko.observable(false);\n"
  "  self.advancedMode.subscribe(function (val) {\n"
  "    self.setCookie(\"advancedMode\", val.toString());\n"
  "  });\n"
  "\n"
  "  // Developer mode\n"
  "  self.developerMode = ko.observable(false);\n"
  "  self.developerMode.subscribe(function (val) {\n"
  "    self.setCookie(\"developerMode\", val.toString());\n"
  "    if(val) {\n"
  "      self.advancedMode(true); // Enabling dev mode implicitly enables advanced mode\n"
  "    }\n"
  "  });\n"
  "\n"
  "  var updateTimer = null;\n"
  "  var updateTime = 5 * 1000;\n"
  "\n"
  "  var scanTimer = null;\n"
  "  var scanTime = 3 * 1000;\n"
  "\n"
  "  // Get time update events\n"
  "  self.status.time.subscribe((time) => {\n"
  "    self.openevse.time.timeUpdate(new Date(time));\n"
  "  });\n"
  "\n"
  "  // Time source\n"
  "  self.timeSource = ko.computed({\n"
  "    read: function() {\n"
  "      return self.config.sntp_enabled() ? \"ntp\" : (\n"
  "        self.openevse.time.automaticTime() ? \"browser\" : \"manual\"\n"
  "      );\n"
  "    },\n"
  "    write: function(val) {\n"
  "      switch(val)\n"
  "      {\n"
  "        case \"ntp\":\n"
  "          self.config.sntp_enabled(true);\n"
  "          self.openevse.time.automaticTime(true);\n"
  "          break;\n"
  "        case \"browser\":\n"
  "          self.config.sntp_enabled(false);\n"
  "          self.openevse.time.automaticTime(true);\n"
  "          break;\n"
  "        case \"manual\":\n"
  "          self.config.sntp_enabled(false);\n"
  "          self.openevse.time.automaticTime(false);\n"
  "          break;\n"
  "      }\n"
  "    }\n"
  "  });\n"
  "\n"
  "  self.time_zone = ko.computed({\n"
  "    read: () => {\n"
  "      return self.config.time_zone();\n"
  "    },\n"
  "    write: (val) => {\n"
  "      if(undefined !== val && false === self.zones.fetching()) {\n"
  "        self.config.time_zone(val);\n"
  "      }\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // Tabs\n"
  "  var tab = \"status\";\n"
  "  if(\"\" !== window.location.hash) {\n"
  "    tab = window.location.hash.substr(1);\n"
  "  }\n"
  "  self.tab = ko.observable(tab);\n"
  "  self.tab.subscribe(function (val) {\n"
  "    window.location.hash = \"#\" + val;\n"
  "  });\n"
  "  self.isSystem = ko.pureComputed(function() { return \"system\" === self.tab(); });\n"
  "  self.isServices = ko.pureComputed(function() { return \"services\" === self.tab(); });\n"
  "  self.isStatus = ko.pureComputed(function() { return \"status\" === self.tab(); });\n"
  "  self.isRapi = ko.pureComputed(function() { return \"rapi\" === self.tab(); });\n"
  "\n"
  "  // Upgrade URL\n"
  "  self.upgradeUrl = ko.observable(\"about:blank\");\n"
  "\n"
  "  // Show/hide password state\n"
  "  self.wifiPassword = new PasswordViewModel(self.config.pass);\n"
  "  self.emoncmsApiKey = new PasswordViewModel(self.config.emoncms_apikey);\n"
  "  self.mqttPassword = new PasswordViewModel(self.config.mqtt_pass);\n"
  "  self.wwwPassword = new PasswordViewModel(self.config.www_password);\n"
  "\n"
  "  function split_emoncms_server() {\n"
  "    var proto = self.config.emoncms_server().split(\"://\", 2);\n"
  "    if(proto.length > 1) {\n"
  "      return proto;\n"
  "    }\n"
  "\n"
  "    return [\n"
  "      self.config.http_supported_protocols()[0],\n"
  "      proto[0]\n"
  "    ];\n"
  "  }\n"
  "\n"
  "  // EmonCMS endpoint config\n"
  "  self.emoncms_protocol = ko.computed({\n"
  "    read: function () {\n"
  "      if(0 == self.config.http_supported_protocols().length) {\n"
  "        return \"\";\n"
  "      }\n"
  "      return split_emoncms_server()[0];\n"
  "    },\n"
  "    write: function(val) {\n"
  "      if(self.config.http_supported_protocols().length > 0) {\n"
  "        self.config.emoncms_server(val + \"://\" + split_emoncms_server()[1]);\n"
  "      }\n"
  "    }\n"
  "  });\n"
  "  self.emoncms_server = ko.computed({\n"
  "    read: function () {\n"
  "      if(0 == self.config.http_supported_protocols().length) {\n"
  "        return self.config.emoncms_server();\n"
  "      }\n"
  "      return split_emoncms_server()[1];\n"
  "    },\n"
  "    write: function(val) {\n"
  "      if(self.config.http_supported_protocols().length > 0) {\n"
  "        var parts = val.split(\"://\", 2);\n"
  "        var proto = parts.length > 1 ? parts[0] : split_emoncms_server()[0];\n"
  "        var host = parts.length > 1 ? parts[1] : val;\n"
  "        self.config.emoncms_server(proto + \"://\" + host);\n"
  "      } else {\n"
  "        self.config.emoncms_server(val);\n"
  "      }\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // MQTT port update\n"
  "  self.config.mqtt_protocol.subscribe((val) => {\n"
  "    switch(val)\n"
  "    {\n"
  "      case \"mqtt\":\n"
  "        if(self.config.mqtt_port() == \"8883\") {\n"
  "          self.config.mqtt_port(\"1883\");\n"
  "        }\n"
  "        break;\n"
  "      case \"mqtts\":\n"
  "        if(self.config.mqtt_port() == \"1883\") {\n"
  "          self.config.mqtt_port(\"8883\");\n"
  "        }\n"
  "        break;\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Initialise the app\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.loadedCount = ko.observable(0);\n"
  "  self.itemsLoaded = ko.pureComputed(function () {\n"
  "    return self.loadedCount() + self.openevse.updateCount();\n"
  "  });\n"
  "  self.itemsTotal = ko.observable(3 + self.openevse.updateTotal());\n"
  "  self.start = function () {\n"
  "    self.updating(true);\n"
  "    self.status.update(function () {\n"
  "      self.loadedCount(self.loadedCount() + 1);\n"
  "      self.config.update(function () {\n"
  "        self.loadedCount(self.loadedCount() + 1);\n"
  "        self.schedule.update(function () {\n"
  "          self.loadedCount(self.loadedCount() + 1);\n"
  "          // If we are accessing on a .local domain try and redirect\n"
  "          if(self.baseHost().endsWith(\".local\") && \"\" !== self.status.ipaddress()) {\n"
  "            if(\"\" === self.config.www_username())\n"
  "            {\n"
  "              // Redirect to the IP internally\n"
  "              self.baseHost(self.status.ipaddress());\n"
  "            } else {\n"
  "              window.location.replace(\"http://\" + self.status.ipaddress() + \":\" + self.basePort());\n"
  "            }\n"
  "          }\n"
  "          if(self.status.rapi_connected()) {\n"
  "            self.openevse.update(self.finishedStarting);\n"
  "          } else {\n"
  "            self.finishedStarting();\n"
  "            self.status.rapi_connected.subscribe((val) => {\n"
  "              if(val) {\n"
  "                self.config.update(() => {\n"
  "                  self.openevse.update(() => {\n"
  "                  });\n"
  "                });\n"
  "              }\n"
  "            });\n"
  "          }\n"
  "        });\n"
  "      });\n"
  "      self.connect();\n"
  "    });\n"
  "\n"
  "    // Set the advanced and developer modes from Cookies\n"
  "    self.advancedMode(self.getCookie(\"advancedMode\", \"false\") === \"true\");\n"
  "    self.developerMode(self.getCookie(\"developerMode\", \"false\") === \"true\");\n"
  "  };\n"
  "\n"
  "  self.finishedStarting = function () {\n"
  "    self.initialised(true);\n"
  "    updateTimer = setTimeout(self.update, updateTime);\n"
  "\n"
  "    // Load the upgrade frame\n"
  "    self.upgradeUrl(self.baseEndpoint() + \"/update\");\n"
  "\n"
  "    // Load the images\n"
  "    var imgDefer = document.getElementsByTagName(\"img\");\n"
  "    for (var i=0; i<imgDefer.length; i++) {\n"
  "      if(imgDefer[i].getAttribute(\"data-src\")) {\n"
  "        imgDefer[i].setAttribute(\"src\", imgDefer[i].getAttribute(\"data-src\"));\n"
  "      }\n"
  "    }\n"
  "\n"
  "    // Load the Time Zone information\n"
  "    if(false !== self.config.time_zone()) {\n"
  "      self.zones.initialValue(self.config.time_zone());\n"
  "      self.zones.update(() => {\n"
  "        self.config.time_zone.valueHasMutated();\n"
  "      });\n"
  "    }\n"
  "\n"
  "    self.updating(false);\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Get the updated state from the ESP\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.update = function () {\n"
  "    if (self.updating()) {\n"
  "      return;\n"
  "    }\n"
  "    self.updating(true);\n"
  "    if (null !== updateTimer) {\n"
  "      clearTimeout(updateTimer);\n"
  "      updateTimer = null;\n"
  "    }\n"
  "    self.status.update(function () {\n"
  "      updateTimer = setTimeout(self.update, updateTime);\n"
  "      self.updating(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // WiFi scan update\n"
  "  // -----------------------------------------------------------------------\n"
  "  var scanEnabled = false;\n"
  "  self.startScan = function () {\n"
  "    if (self.scanUpdating()) {\n"
  "      return;\n"
  "    }\n"
  "    scanEnabled = true;\n"
  "    self.scanUpdating(true);\n"
  "    if (null !== scanTimer) {\n"
  "      clearTimeout(scanTimer);\n"
  "      scanTimer = null;\n"
  "    }\n"
  "    self.scan.update(function () {\n"
  "      if(scanEnabled) {\n"
  "        scanTimer = setTimeout(self.startScan, scanTime);\n"
  "      }\n"
  "      self.scanUpdating(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  self.stopScan = function() {\n"
  "    scanEnabled = false;\n"
  "    if (self.scanUpdating()) {\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    if (null !== scanTimer) {\n"
  "      clearTimeout(scanTimer);\n"
  "      scanTimer = null;\n"
  "    }\n"
  "  };\n"
  "\n"
  "  self.wifiConnecting = ko.observable(false);\n"
  "  self.status.mode.subscribe(function (newValue) {\n"
  "    if(newValue === \"STA+AP\" || newValue === \"STA\") {\n"
  "      self.wifiConnecting(false);\n"
  "    }\n"
  "    if(newValue === \"STA+AP\" || newValue === \"AP\") {\n"
  "      self.startScan();\n"
  "    } else {\n"
  "      self.stopScan();\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: WiFi Connect\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.saveNetworkFetching = ko.observable(false);\n"
  "  self.saveNetworkSuccess = ko.observable(false);\n"
  "  self.saveNetwork = function () {\n"
  "    if (self.config.ssid() === \"\") {\n"
  "      alert(\"Please select network\");\n"
  "    } else {\n"
  "      self.saveNetworkFetching(true);\n"
  "      self.saveNetworkSuccess(false);\n"
  "      $.post(self.baseEndpoint() + \"/savenetwork\", { ssid: self.config.ssid(), pass: self.config.pass() }, function () {\n"
  "        self.saveNetworkSuccess(true);\n"
  "        self.wifiConnecting(true);\n"
  "      }).fail(function () {\n"
  "        alert(\"Failed to save WiFi config\");\n"
  "      }).always(function () {\n"
  "        self.saveNetworkFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Admin save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.saveAdminFetching = ko.observable(false);\n"
  "  self.saveAdminSuccess = ko.observable(false);\n"
  "  self.saveAdmin = function () {\n"
  "    self.saveAdminFetching(true);\n"
  "    self.saveAdminSuccess(false);\n"
  "    $.post(self.baseEndpoint() + \"/saveadmin\", { user: self.config.www_username(), pass: self.config.www_password() }, function () {\n"
  "      self.saveAdminSuccess(true);\n"
  "    }).fail(function () {\n"
  "      alert(\"Failed to save Admin config\");\n"
  "    }).always(function () {\n"
  "      self.saveAdminFetching(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Advanced save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.advancedGroup = new ConfigGroupViewModel(self.baseEndpoint, () => {\n"
  "    return {\n"
  "      hostname: self.config.hostname(),\n"
  "      sntp_hostname: self.config.sntp_hostname()\n"
  "    };\n"
  "  }).done(() => {\n"
  "    if (confirm(\"These changes require a reboot to take effect. Reboot now?\")) {\n"
  "      $.post(self.baseEndpoint() + \"/restart\", { }, function () {\n"
  "        setTimeout(() => {\n"
  "          var newLocation = \"http://\" + self.config.hostname() + \".local\";\n"
  "          if(80 != self.basePort()) {\n"
  "            newLocation += \":\" + self.basePort();\n"
  "          }\n"
  "          newLocation += \"/\";\n"
  "          window.location.replace(newLocation);\n"
  "        }, 5*1000);\n"
  "      }).fail(function () {\n"
  "        alert(\"Failed to restart\");\n"
  "      });\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Emoncms save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.saveEmonCmsFetching = ko.observable(false);\n"
  "  self.saveEmonCmsSuccess = ko.observable(false);\n"
  "  self.saveEmonCms = function () {\n"
  "    var emoncms = {\n"
  "      enable: self.config.emoncms_enabled(),\n"
  "      server: self.config.emoncms_server(),\n"
  "      apikey: self.config.emoncms_apikey(),\n"
  "      node: self.config.emoncms_node(),\n"
  "      fingerprint: self.config.emoncms_fingerprint()\n"
  "    };\n"
  "\n"
  "    if (emoncms.enable && (emoncms.server === \"\" || emoncms.node === \"\")) {\n"
  "      alert(\"Please enter Emoncms server and node\");\n"
  "    } else if (emoncms.enable && emoncms.apikey.length !== 32 && !self.emoncmsApiKey.isDummy()) {\n"
  "      alert(\"Please enter valid Emoncms apikey\");\n"
  "    } else if (emoncms.enable && emoncms.fingerprint !== \"\" && emoncms.fingerprint.length !== 59) {\n"
  "      alert(\"Please enter valid SSL SHA-1 fingerprint\");\n"
  "    } else {\n"
  "      self.saveEmonCmsFetching(true);\n"
  "      self.saveEmonCmsSuccess(false);\n"
  "      $.post(self.baseEndpoint() + \"/saveemoncms\", emoncms, function () {\n"
  "        self.saveEmonCmsSuccess(true);\n"
  "      }).fail(function () {\n"
  "        alert(\"Failed to save Admin config\");\n"
  "      }).always(function () {\n"
  "        self.saveEmonCmsFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: MQTT save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.mqttGroup = new ConfigGroupViewModel(self.baseEndpoint, () => {\n"
  "    return {\n"
  "      mqtt_enabled: self.config.mqtt_enabled(),\n"
  "      divert_enabled: self.config.divert_enabled(),\n"
  "      mqtt_protocol: self.config.mqtt_protocol(),\n"
  "      mqtt_server: self.config.mqtt_server(),\n"
  "      mqtt_port: self.config.mqtt_port(),\n"
  "      mqtt_reject_unauthorized: self.config.mqtt_reject_unauthorized(),\n"
  "      mqtt_topic: self.config.mqtt_topic(),\n"
  "      mqtt_user: self.config.mqtt_user(),\n"
  "      mqtt_pass: self.config.mqtt_pass(),\n"
  "      mqtt_vrms: self.config.mqtt_vrms()\n"
  "    };\n"
  "  }).validate((mqtt) => {\n"
  "    if(!self.config.mqtt_enabled()) {\n"
  "      self.config.divert_enabled(false);\n"
  "    }\n"
  "\n"
  "    if (mqtt.mqtt_enabled && mqtt.mqtt_server === \"\") {\n"
  "      alert(\"Please enter MQTT server\");\n"
  "      return false;\n"
  "    }\n"
  "\n"
  "    return true;\n"
  "  });\n"
  "\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Vehicle settings save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.vehicleGroup = new ConfigGroupViewModel(self.baseEndpoint, () => {\n"
  "    return {\n"
  "      pause_uses_disabled: self.config.pause_uses_disabled()\n"
  "    };\n"
  "  });\n"
  "  self.config.pause_uses_disabled.subscribe(() => {\n"
  "    self.vehicleGroup.save();\n"
  "  });\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: PV Divert save\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.divertGroup = new ConfigGroupViewModel(self.baseEndpoint, () => {\n"
  "    return {\n"
  "      divert_enabled: self.config.divert_enabled(),\n"
  "      mqtt_solar: self.config.mqtt_solar(),\n"
  "      mqtt_grid_ie: self.config.mqtt_grid_ie(),\n"
  "      divert_PV_ratio: self.config.divert_PV_ratio(),\n"
  "      divert_attack_smoothing_factor: self.config.divert_attack_smoothing_factor(),\n"
  "      divert_decay_smoothing_factor: self.config.divert_decay_smoothing_factor(),\n"
  "      divert_min_charge_time: self.config.divert_min_charge_time()\n"
  "    };\n"
  "  }).validate((divert) => {\n"
  "    if (divert.divert_enabled && divert.mqtt_solar === \"\" && divert.mqtt_grid_ie === \"\") {\n"
  "      alert(\"Please enter either a Solar PV or Grid I/E feed\");\n"
  "      return false;\n"
  "    }\n"
  "\n"
  "    return true;\n"
  "  });\n"
  "\n"
  "  self.chargeMode = new ConfigGroupViewModel(self.baseEndpoint, () => {\n"
  "    return {\n"
  "      charge_mode: self.config.charge_mode()\n"
  "    };\n"
  "  });\n"
  "\n"
  "  self.isEcoModeAvailable = ko.pureComputed(function () {\n"
  "    return self.config.mqtt_enabled() &&\n"
  "           (\"\" !== self.config.mqtt_solar() ||\n"
  "            \"\" !== self.config.mqtt_grid_ie());\n"
  "  });\n"
  "\n"
  "  self.ecoMode = ko.pureComputed({\n"
  "    read: function () {\n"
  "      return \"eco\" === self.config.charge_mode();\n"
  "    },\n"
  "    write: function(val) {\n"
  "      self.config.charge_mode((val && self.config.divert_enabled()) ? \"eco\" : \"fast\");\n"
  "      self.chargeMode.save();\n"
  "    }\n"
  "  });\n"
  "\n"
  "  self.status.divertmode.subscribe((val) => {\n"
  "    switch(val)\n"
  "    {\n"
  "      case 1: self.config.charge_mode(\"fast\"); break;\n"
  "      case 2: self.config.charge_mode(\"eco\"); break;\n"
  "    }\n"
  "  });\n"
  "\n"
  "  self.haveSolar = ko.pureComputed(function () {\n"
  "    return \"\" !== self.config.mqtt_solar();\n"
  "  });\n"
  "\n"
  "  self.haveGridIe =ko.pureComputed(function () {\n"
  "    return \"\" !== self.config.mqtt_grid_ie();\n"
  "  });\n"
  "\n"
  "  self._divertFeedType = \"grid_ie\";\n"
  "  self.divertFeedType = ko.computed({\n"
  "    read: () => {\n"
  "      var ret = self.haveSolar() ? \"solar\" :\n"
  "                self.haveGridIe() ? \"grid_ie\" : \n"
  "                self._divertFeedType;\n"
  "      self._divertFeedType = ret;\n"
  "      return ret;\n"
  "    },\n"
  "    write: (val) => {\n"
  "      if(\"solar\" === val && self.haveGridIe()) {\n"
  "        self.config.mqtt_solar(self.config.mqtt_grid_ie());\n"
  "        self.config.mqtt_grid_ie(\"\");\n"
  "      } else if(\"grid_ie\" === val && self.haveSolar()) {\n"
  "        self.config.mqtt_grid_ie(self.config.mqtt_solar());\n"
  "        self.config.mqtt_solar(\"\");\n"
  "      }\n"
  "      self._divertFeedType = val;\n"
  "    }\n"
  "  });\n"
  "  self.divertFeedValue = ko.computed({\n"
  "    read: () => {\n"
  "      return \"solar\" === self.divertFeedType() ? \n"
  "                self.config.mqtt_solar() :\n"
  "                self.config.mqtt_grid_ie();\n"
  "    },\n"
  "    write: (val) => {\n"
  "      if(\"solar\" === self.divertFeedType()) {\n"
  "        self.config.mqtt_solar(val);\n"
  "      } else {\n"
  "        self.config.mqtt_grid_ie(val);\n"
  "      }\n"
  "    }\n"
  "  });\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Save Ohm Connect Key\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.saveOhmKeyFetching = ko.observable(false);\n"
  "  self.saveOhmKeySuccess = ko.observable(false);\n"
  "  self.saveOhmKey = function () {\n"
  "    self.saveOhmKeyFetching(true);\n"
  "    self.saveOhmKeySuccess(false);\n"
  "    $.post(self.baseEndpoint() + \"/saveohmkey\", {\n"
  "      enable: self.config.ohm_enabled(),\n"
  "      ohm: self.config.ohmkey()\n"
  "    }, function () {\n"
  "      self.saveOhmKeySuccess(true);\n"
  "    }).fail(function () {\n"
  "      alert(\"Failed to save Ohm key config\");\n"
  "    }).always(function () {\n"
  "      self.saveOhmKeyFetching(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Set the time\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.setTimeFetching = ko.observable(false);\n"
  "  self.setTimeSuccess = ko.observable(false);\n"
  "  self.setTime = function () {\n"
  "    self.setTimeFetching(true);\n"
  "    self.setTimeSuccess(false);\n"
  "\n"
  "    var newTime = self.openevse.time.automaticTime() ? new Date() : self.openevse.time.evseTimedate();\n"
  "    if(false == self.status.time())\n"
  "    {\n"
  "      self.openevse.openevse.time((date,valid=true) => {\n"
  "        self.setTimeFetching(false);\n"
  "        self.setTimeSuccess(valid);\n"
  "\n"
  "        self.openevse.time.timeUpdate(date, valid);\n"
  "      }, newTime);\n"
  "    } else {\n"
  "      var sntp = self.config.sntp_enabled();\n"
  "\n"
  "      var params = {\n"
  "        ntp: sntp,\n"
  "        tz: self.time_zone()\n"
  "      };\n"
  "      if(false === sntp) {\n"
  "        params.time = newTime.toISOString();\n"
  "      }\n"
  "\n"
  "      $.post(self.baseEndpoint() + \"/settime\", params, () => {\n"
  "        self.setTimeFetching(false);\n"
  "        self.setTimeSuccess(true);\n"
  "      }).fail(() => {\n"
  "        alert(\"Failed to set time\");\n"
  "        self.setTimeFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Turn off Access Point\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.turnOffAccessPointFetching = ko.observable(false);\n"
  "  self.turnOffAccessPointSuccess = ko.observable(false);\n"
  "  self.turnOffAccessPoint = function () {\n"
  "    self.turnOffAccessPointFetching(true);\n"
  "    self.turnOffAccessPointSuccess(false);\n"
  "    $.post(self.baseEndpoint() + \"/apoff\", {\n"
  "    }, function (data) {\n"
  "      console.log(data);\n"
  "      if (self.status.ipaddress() !== \"\") {\n"
  "        setTimeout(function () {\n"
  "          window.location = \"http://\" + self.status.ipaddress();\n"
  "          self.turnOffAccessPointSuccess(true);\n"
  "        }, 3000);\n"
  "      } else {\n"
  "        self.turnOffAccessPointSuccess(true);\n"
  "      }\n"
  "    }).fail(function () {\n"
  "      alert(\"Failed to turn off Access Point\");\n"
  "    }).always(function () {\n"
  "      self.turnOffAccessPointFetching(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Reset config and reboot\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.factoryResetFetching = ko.observable(false);\n"
  "  self.factoryResetSuccess = ko.observable(false);\n"
  "  self.factoryReset = function() {\n"
  "    if (confirm(\"CAUTION: Do you really want to Factory Reset? All setting and config will be lost.\")) {\n"
  "      self.factoryResetFetching(true);\n"
  "      self.factoryResetSuccess(false);\n"
  "      $.post(self.baseEndpoint() + \"/reset\", { }, function () {\n"
  "        self.factoryResetSuccess(true);\n"
  "      }).fail(function () {\n"
  "        alert(\"Failed to Factory Reset\");\n"
  "      }).always(function () {\n"
  "        self.factoryResetFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Restart\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.restartFetching = ko.observable(false);\n"
  "  self.restartSuccess = ko.observable(false);\n"
  "  self.restart = function() {\n"
  "    if (confirm(\"Restart OpenEVSE WiFi? Current config will be saved, takes approximately 10s.\")) {\n"
  "      self.restartFetching(true);\n"
  "      self.restartSuccess(false);\n"
  "      $.post(self.baseEndpoint() + \"/restart\", { }, function () {\n"
  "        self.restartSuccess(true);\n"
  "      }).fail(function () {\n"
  "        alert(\"Failed to restart\");\n"
  "      }).always(function () {\n"
  "        self.restartFetching(false);\n"
  "      });\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Event: Update\n"
  "  // -----------------------------------------------------------------------\n"
  "\n"
  "  // Support for OTA update of the OpenEVSE\n"
  "  self.updateFetching = ko.observable(false);\n"
  "  self.updateComplete = ko.observable(false);\n"
  "  self.updateError = ko.observable(\"\");\n"
  "  self.updateFilename = ko.observable(\"\");\n"
  "  self.updateLoaded = ko.observable(0);\n"
  "  self.updateTotal = ko.observable(1);\n"
  "  self.updateProgress = ko.pureComputed(function () {\n"
  "    return (self.updateLoaded() / self.updateTotal()) * 100;\n"
  "  });\n"
  "\n"
  "  self.otaUpdate = function() {\n"
  "    if(\"\" === self.updateFilename()) {\n"
  "      self.updateError(\"Filename not set\");\n"
  "      return;\n"
  "    }\n"
  "\n"
  "    self.updateFetching(true);\n"
  "    self.updateError(\"\");\n"
  "\n"
  "    var form = $(\"#upload_form\")[0];\n"
  "    var data = new FormData(form);\n"
  "\n"
  "    $.ajax({\n"
  "      url: \"/update\",\n"
  "      type: \"POST\",\n"
  "      data: data,\n"
  "      contentType: false,\n"
  "      processData:false,\n"
  "      xhr: function() {\n"
  "        var xhr = new window.XMLHttpRequest();\n"
  "        xhr.upload.addEventListener(\"progress\", function(evt) {\n"
  "          if (evt.lengthComputable) {\n"
  "            self.updateLoaded(evt.loaded);\n"
  "            self.updateTotal(evt.total);\n"
  "          }\n"
  "        }, false);\n"
  "        return xhr;\n"
  "      }\n"
  "    }).done(function(msg) {\n"
  "      console.log(msg);\n"
  "      if(\"OK\" == msg) {\n"
  "        self.updateComplete(true);\n"
  "      } else {\n"
  "        self.updateError(msg);\n"
  "      }\n"
  "    }).fail(function () {\n"
  "      self.updateError(\"HTTP Update failed\");\n"
  "    }).always(function () {\n"
  "      self.updateFetching(false);\n"
  "    });\n"
  "  };\n"
  "\n"
  "  // -----------------------------------------------------------------------\n"
  "  // Receive events from the server\n"
  "  // -----------------------------------------------------------------------\n"
  "  self.pingInterval = false;\n"
  "  self.reconnectInterval = false;\n"
  "  self.socket = false;\n"
  "  self.connect = function () {\n"
  "    self.socket = new WebSocket(self.wsEndpoint());\n"
  "    self.socket.onopen = function (ev) {\n"
  "      console.log(ev);\n"
  "      self.pingInterval = setInterval(function () {\n"
  "        self.socket.send(\"{\\\"ping\\\":1}\");\n"
  "      }, 1000);\n"
  "    };\n"
  "    self.socket.onclose = function (ev) {\n"
  "      console.log(ev);\n"
  "      self.reconnect();\n"
  "    };\n"
  "    self.socket.onmessage = function (msg) {\n"
  "      console.log(msg);\n"
  "      ko.mapping.fromJSON(msg.data, self.status);\n"
  "    };\n"
  "    self.socket.onerror = function (ev) {\n"
  "      console.log(ev);\n"
  "      self.socket.close();\n"
  "      self.reconnect();\n"
  "    };\n"
  "  };\n"
  "  self.reconnect = function() {\n"
  "    if(false !== self.pingInterval) {\n"
  "      clearInterval(self.pingInterval);\n"
  "      self.pingInterval = false;\n"
  "    }\n"
  "    if(false === self.reconnectInterval) {\n"
  "      self.reconnectInterval = setTimeout(function () {\n"
  "        self.reconnectInterval = false;\n"
  "        self.connect();\n"
  "      }, 500);\n"
  "    }\n"
  "  };\n"
  "\n"
  "  // Cookie management, based on https://www.w3schools.com/js/js_cookies.asp\n"
  "  self.setCookie = function (cname, cvalue, exdays = false) {\n"
  "    var expires = \"\";\n"
  "    if(false !== exdays) {\n"
  "      var d = new Date();\n"
  "      d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));\n"
  "      expires = \";expires=\"+d.toUTCString();\n"
  "    }\n"
  "    document.cookie = cname + \"=\" + cvalue + expires + \";path=/\";\n"
  "  };\n"
  "\n"
  "  self.getCookie = function (cname, def = \"\") {\n"
  "    var name = cname + \"=\";\n"
  "    var ca = document.cookie.split(\";\");\n"
  "    for(var i = 0; i < ca.length; i++) {\n"
  "      var c = ca[i];\n"
  "      while (c.charAt(0) === \" \") {\n"
  "        c = c.substring(1);\n"
  "      }\n"
  "      if (c.indexOf(name) === 0) {\n"
  "        return c.substring(name.length, c.length);\n"
  "      }\n"
  "    }\n"
  "    return def;\n"
  "  };\n"
  "}\n"
  "\n"
  "/* global $, ko, OpenEvseWiFiViewModel */\n"
  "\n"
  "(function() {\n"
  "  \"use strict\";\n"
  "\n"
  "  // Configure the endpoint to use, for dev you can change to point at a remote ESP\n"
  "  // and run the HTML/JS from file, no need to upload to the ESP to test\n"
  "\n"
  "  var baseHost = window.location.hostname;\n"
  "  //var baseHost = \"openevse.local\";\n"
  "  //var baseHost = \"192.168.4.1\";\n"
  "  //var baseHost = \"172.16.0.70\";\n"
  "\n"
  "  var basePort = window.location.port;\n"
  "  var baseProtocol = window.location.protocol;\n"
  "\n"
  "  // DEBUG\n"
  "  // console.log(baseHost);\n"
  "  // console.log(basePort);\n"
  "  // console.log(baseProtocol);\n"
  "\n"
  "  $(function () {\n"
  "  // Activates knockout.js\n"
  "    var openevse = new OpenEvseWiFiViewModel(baseHost, basePort, baseProtocol);\n"
  "    ko.applyBindings(openevse);\n"
  "    openevse.start();\n"
  "  });\n"
  "\n"
  "})();\n"
  "\n"
  "\n"
  "// Convert string to number, divide by scale, return result\n"
  "// as a string with specified precision\n"
  "/* exported scaleString */\n"
  "function scaleString(string, scale, precision) {\n"
  "  \"use strict\";\n"
  "  var tmpval = (\"number\" === (typeof string) ? string : parseInt(string)) / scale;\n"
  "  return tmpval.toFixed(precision);\n"
  "}\n"
  "\n"
  "// Based on https://github.com/emoncms/emoncms/blob/master/Lib/tablejs/custom-table-fields.js#L176-L203\n"
  "/* exported formatUpdate */\n"
  "function formatUpdate(secs) {\n"
  "  \"use strict\";\n"
  "\n"
  "  if(false === secs) {\n"
  "    return \"N/A\";\n"
  "  }\n"
  "\n"
  "  var mins = secs/60;\n"
  "  var hour = secs/3600;\n"
  "  var day = hour/24;\n"
  "\n"
  "  var updated = secs.toFixed(0) + \"s\";\n"
  "  if (secs.toFixed(0) === 0) {\n"
  "    updated = \"now\";\n"
  "  } else if (day>7) {\n"
  "    updated = \"inactive\";\n"
  "  } else if (day>2) {\n"
  "    updated = day.toFixed(1)+\" days\";\n"
  "  } else if (hour>2) {\n"
  "    updated = hour.toFixed(0)+\" hrs\";\n"
  "  } else if (secs>180) {\n"
  "    updated = mins.toFixed(0)+\" mins\";\n"
  "  }\n"
  "\n"
  "  return updated;\n"
  "}\n"
  "\n"
  "// Based on https://github.com/emoncms/emoncms/blob/master/Lib/tablejs/custom-table-fields.js#L176-L203\n"
  "/* exported updateClass */\n"
  "function updateClass(secs) {\n"
  "  \"use strict\";\n"
  "\n"
  "  if(false === secs) {\n"
  "    return \"\";\n"
  "  }\n"
  "\n"
  "  secs = Math.abs(secs);\n"
  "  var updateClass = \"updateBad\";\n"
  "  if (secs<25) {\n"
  "    updateClass = \"updateGood\";\n"
  "  } else if (secs<60) {\n"
  "    updateClass = \"updateSlow\";\n"
  "  } else if (secs<(3600*2)) {\n"
  "    updateClass = \"updateSlower\";\n"
  "  }\n"
  "\n"
  "  return updateClass;\n"
  "}\n";
